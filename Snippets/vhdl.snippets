snippet library "std and numeric libraries"
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;
endsnippet

#jihuu
snippet package
package ${1:`Filename()`} is

end package $1;
endsnippet

snippet library_work "use library"
library $1;
	use $1.$2.${3:all};
endsnippet


snippet variable
variable $1 : $2
endsnippet

snippet constant 
constant $1 : $2 := $3;
endsnippet

snippet process "clocked process"
$1 : process(${2:clk})
	$3
begin
	if rising_edge($2) then
		if ${4:rstn} = '0' then
		-- reset state

		else

		end if; -- rstn
	end if; --rising_edge
end process $1;	
endsnippet

snippet process2 "asynchronous reset in clocked process"
$1 : process(${2:clk}, ${3:rstn})
begin
	if $3 = ${4:'0'} then
	-- reset state

	elsif rising_edge($2) then

	end if; -- rstn
end process $1;	
endsnippet

snippet process_unclocked "unclocked process"
$1 : process(${2:clk})
	$3
begin

end process $1;	
endsnippet

#== type declarations
snippet unsigned "unsigned x downto 0"
unsigned($1 downto 0);
endsnippet

snippet signed "signed x downto 0"
signed($1 downto 0);
endsnippet

snippet std_logic_vector 
std_logic_vector($1 downto 0);
endsnippet

snippet std_logic	
std_logic;
endsnippet

snippet test_python "simple" !b
`!p snip.rv = "hello"`
endsnippet

snippet uuid "UUID" !b
`!p import uuid
if not snip.c:
	snip.rv =uuid.uuid4().hex`
endsnippet

global !p
def complete(t, opts):
	if t:
		opts =[m[len(t):] for m in opts if m.startswith(t)]
	if len(opts) == 1:
		return opts[0]
	return "(" +'|'.join(opts) + ')'
endglobal

snippet status 
status $1`!p snip.rv=complete(t[1],['new','incomplete','invalid'])`
endsnippet

snippet entity "entity without work library"
entity ${1:top} is
	port (
		${2:clk : in std_logic}	
	);
end entity $1;


architecture ${2:rtl} of $1 is
$3

begin
$4

end $2;
endsnippet


snippet if "if-else"
if $1 then
	$2
end if; --$1
endsnippet

snippet case "CASE-end CASE"
CASE $1 is
	$2
end CASE; --$1
endsnippet

snippet library
library $1;
	use $1.$2.all;
endsnippet

snippet record
type $1 is record
	$2`!p snip.rv=complete(t[2],['data : std_logic;'])`
end record;
endsnippet

snippet type_states
type t_$1 is ($2);
$3`!p snip.rv=complete(t[3],['variable', 'signal'])` st_$1 : t_$1;
endsnippet


snippet architecture
architecture $1 of $2 is
$3

begin

$4

end $1;
endsnippet

snippet signal_i
signal $1 : in $2 
endsnippet

snippet signal_o
signal $1 : out $2 
endsnippet

snippet signal_io
signal $1 : inout $2 
endsnippet

snippet signal 
signal $1 : $2 
endsnippet

snippet procedure
procedure $1
(
	$2
) is
begin
	$3
end $1;
endsnippet

snippet function
function $1
(
	$2
)
return $3
is
begin
	$4
end $1;
endsnippet

snippet danfoss_sw_header
--------------------------------------------------------------------------------------------------------------------------------
-- This confidential and proprietary software may be used only as authorized by a licensing agreement from Danfoss Editron Oy
--
-- (C) COPYRIGHT 2019 DANFOSS EDITRON OY, ALL RIGHTS RESERVED
--
-- Description
--   $1
--
--   
--
--------------------------------------------------------------------------------------------------------------------------------
endsnippet

snippet testbench
LIBRARY ieee  ; 
LIBRARY std  ; 
    USE ieee.NUMERIC_STD.all  ; 
    USE ieee.std_logic_1164.all  ; 
    USE ieee.std_logic_textio.all  ; 
    use ieee.math_real.all;
    USE std.textio.all  ; 

entity tb_$1 is
end;

architecture sim of tb_$1 is
    signal rstn : std_logic;

    signal simulation_running : boolean;
    signal simulator_clock : std_logic;
    constant clock_per : time := 1 ns;
    constant clock_half_per : time := 0.5 ns;
	constant simtime_in_clocks : integer := 50;


begin

    simtime : process
    begin
        simulation_running <= true;
        wait for simtime_in_clocks*clock_per;
        simulation_running <= false;
        wait;
    end process simtime;	


    sim_clock_gen : process
    begin
        simulator_clock <= '0';
        rstn <= '0';
		simulator_clock <= '0';
        wait for clock_half_per;
        while simulation_running loop
            wait for clock_half_per;
                rstn <= '1';
                simulator_clock <= not simulator_clock;
            end loop;
        wait;
    end process;

end sim;
endsnippet

snippet array
type $1 is array (integer range 0 to $2) of $3;
endsnippet
